<script>
console.group('Document Initialization');
console.log('DOM Content Loaded - Starting page setup...');

document.addEventListener("DOMContentLoaded", function() {
    console.time('Page Initialization Time');

    // Ambil title dari halaman
     // Ambil title dari halaman (hasil render YAML)
    var pageTitle = document.querySelector("h1.title")?.innerText || "Judul Tidak Ada";
    console.log('Page Title:', pageTitle);

    // Jika ingin subtitle:
    var pageSubtitle = document.querySelector("h4.subtitle")?.innerText || "";
    console.log('Page Subtitle:', pageSubtitle || 'None');

    // Ambil author dari halaman (hasil render YAML)
    var pageAuthor = document.querySelector("p.author")?.innerText ||
                     document.querySelector(".author")?.innerText ||
                     "Author Tidak Ada";
    console.log('Page Author:', pageAuthor);

    // Set ke sidebar
    const sidebarTitleEl = document.getElementById("sidebarTitle");
    if (sidebarTitleEl) {
        sidebarTitleEl.innerText = pageTitle;
        console.log('Sidebar title set successfully');
    } else {
        console.warn('Sidebar title element not found');
    }

    // Set ke topbar
    const pageTitleEl = document.getElementById("pageTitle");
    if (pageTitleEl) {
        pageTitleEl.innerText = pageTitle;
        console.log('Topbar title set successfully');
    } else {
        console.warn('Topbar title element not found');
    }

    // Set author ke sidebar
    const authorDiv = document.querySelector('.sidebar-author');
    if (authorDiv && pageAuthor !== "Author Tidak Ada") {
        authorDiv.innerHTML = pageAuthor.replace(/\n/g, '<br>');
        console.log('Author info set in sidebar successfully');
    } else {
        console.log('Author info not set (no author div or default author)');
    }

    // Set initial collapsed state
    document.body.classList.add('sidebar-collapsed');
    console.log('Sidebar set to collapsed state');

    // Build sidebar dengan smart detection
    console.log('Building smart sidebar...');
    buildSmartSidebar();

    // Initialize fitur dasar
    console.log('Initializing UI features...');
    initSidebarToggle();
    initThemeToggle();
    initSmoothScroll();
    initSmartAutoSidebar();
    initSearch();
    initRotatingText();

    console.timeEnd('Page Initialization Time');
    console.log('Page initialization complete');
    console.groupEnd();
});

function buildSmartSidebar() {
    console.log('buildSmartSidebar: Starting sidebar construction');

    const sidebarMenu = document.querySelector(".sidebar-menu");
    if (!sidebarMenu) {
        console.warn('buildSmartSidebar: Sidebar menu element not found');
        return;
    }

    sidebarMenu.innerHTML = "";
    console.log('buildSmartSidebar: Cleared existing sidebar content');

    const main = document.querySelector(".main-container") ||
                 document.querySelector(".container-fluid") ||
                 document.body;

    // DEBUG: Lihat semua heading dan parent-nya
    const allHeadings = Array.from(main.querySelectorAll("h1, h2, h3"));
    console.log(`buildSmartSidebar: Found ${allHeadings.length} total headings`);

    allHeadings.forEach((h, i) => {
        console.log(`Heading ${i}:`, {
            text: h.textContent.substring(0, 50),
            tag: h.tagName,
            id: h.id,
            class: h.className,
            parent: h.parentElement?.className || h.parentElement?.tagName,
            parentTag: h.parentElement?.tagName,
            parentId: h.parentElement?.id,
            html: h.outerHTML.substring(0, 100)
        });
    });

    // FILTER: Ambil hanya heading yang dihasilkan dari Markdown (#)
    // Exclude headings in header-container or with author-info (manual HTML headings)
    const headings = allHeadings.filter(h =>
        !h.classList.contains('title') &&
        h.textContent.trim().length > 0 &&
        isMarkdownGeneratedHeading(h) &&
        !h.closest('.header-container') &&
        !h.querySelector('.author-info')
    );

    console.log(`buildSmartSidebar: Filtered to ${headings.length} valid markdown headings`);

    let currentH1 = null;
    let currentH2 = null;
    let hasH1 = headings.some(h => parseInt(h.tagName.substring(1)) === 1);

    console.log(`buildSmartSidebar: H1 presence detected: ${hasH1}`);

    headings.forEach((heading, index) => {
        const level = parseInt(heading.tagName.substring(1));

        // Jika tidak ada H1, treat H2 sebagai H1, H3 sebagai H2
        const effectiveLevel = (!hasH1 && level === 2) ? 1 : (!hasH1 && level === 3) ? 2 : level;

        if (!heading.id) {
            heading.id = `section-${index}-${Date.now()}`;
            console.log(`buildSmartSidebar: Assigned ID ${heading.id} to heading "${heading.textContent.substring(0, 30)}..."`);
        }

        const li = document.createElement("li");
        li.className = `sidebar-lvl-${effectiveLevel}`;
        li.setAttribute('data-level', effectiveLevel);
        li.setAttribute('data-heading-id', heading.id);

        const a = document.createElement("a");
        a.href = "#" + heading.id;
        a.textContent = heading.textContent;
        a.setAttribute('data-section', heading.id);

        a.addEventListener('click', function(e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute('href'));
            if (target) {
                target.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
                console.log(`buildSmartSidebar: Smooth scroll to section ${heading.id}`);
            }
        });

        li.appendChild(a);

        // Atur hierarchy berdasarkan effective level
        if (effectiveLevel === 1) {
            sidebarMenu.appendChild(li);
            currentH1 = li;
            currentH2 = null;
            console.log(`buildSmartSidebar: Added level 1 item: ${heading.textContent.substring(0, 30)}...`);
        } else if (effectiveLevel === 2 && currentH1) {
            let h2Container = currentH1.querySelector('.h2-container');
            if (!h2Container) {
                h2Container = document.createElement('ul');
                h2Container.className = 'h2-container collapsed';
                currentH1.appendChild(h2Container);
                console.log('buildSmartSidebar: Created H2 container');
            }
            h2Container.appendChild(li);
            currentH2 = li;
            console.log(`buildSmartSidebar: Added level 2 item: ${heading.textContent.substring(0, 30)}...`);
        } else if (effectiveLevel === 3 && currentH2) {
            let h3Container = currentH2.querySelector('.h3-container');
            if (!h3Container) {
                h3Container = document.createElement('ul');
                h3Container.className = 'h3-container collapsed';
                currentH2.appendChild(h3Container);
                console.log('buildSmartSidebar: Created H3 container');
            }
            h3Container.appendChild(li);
            console.log(`buildSmartSidebar: Added level 3 item: ${heading.textContent.substring(0, 30)}...`);
        }
    });

    console.log('buildSmartSidebar: Sidebar construction completed');
}


// FUNCTION BARU: Smart detection untuk heading Markdown
function isMarkdownGeneratedHeading(headingElement) {
    const html = headingElement.outerHTML;
    const text = headingElement.textContent.trim();
    
    // 1. Deteksi berdasarkan HTML structure
    // Heading Markdown biasanya punya structure yang clean
    const isCleanHTML = !html.includes('</h1>') && !html.includes('</h2>') && !html.includes('</h3>');
    
    // 2. Deteksi berdasarkan parent context
    // Heading Markdown biasanya langsung di dalam container content
    const parent = headingElement.parentElement;
    const isInContentContainer = parent?.classList?.contains('main-container') || 
                                parent?.classList?.contains('container-fluid') ||
                                parent?.tagName === 'DIV';
    
    // 3. Deteksi berdasarkan sibling elements
    // Heading Markdown biasanya diikuti oleh paragraph atau content lain
    const nextSibling = headingElement.nextElementSibling;
    const hasContentSiblings = nextSibling && 
                              (nextSibling.tagName === 'P' || 
                               nextSibling.tagName === 'DIV' || 
                               nextSibling.tagName === 'PRE');
    
    // 4. Deteksi berdasarkan text pattern
    // Heading HTML manual sering pendek atau spesifik
    const isLongEnough = text.length > 2;
    const hasNormalText = !text.match(/^[0-9\.\s]+$/) && // bukan cuma angka/titik
                         !text.match(/^[A-Z\s]+$/) &&    // bukan cuma uppercase
                         text.indexOf('<') === -1;       // tidak mengandung HTML tags
    
    // 5. Deteksi berdasarkan R Markdown specific attributes
    const hasRMarks = headingElement.classList.contains('section') ||
                     headingElement.hasAttribute('data-number') ||
                     headingElement.previousElementSibling?.tagName === 'H1' ||
                     headingElement.previousElementSibling?.tagName === 'H2';

    // Kombinasi logic: Jika memenuhi kriteria Markdown
    const markdownScore = 
        (isCleanHTML ? 1 : 0) +
        (isInContentContainer ? 1 : 0) + 
        (hasContentSiblings ? 1 : 0) +
        (isLongEnough ? 1 : 0) +
        (hasNormalText ? 1 : 0) +
        (hasRMarks ? 2 : 0); // Extra points untuk R Markdown attributes

    // Threshold: score >= 3 dianggap sebagai Markdown heading
    return markdownScore >= 3;
}

function initSmartAutoSidebar() {
    const main = document.querySelector(".main-container") || 
                 document.querySelector(".container-fluid") || 
                 document.body;
    
    // Gunakan filter yang sama untuk observer
    const sections = Array.from(main.querySelectorAll("h1, h2, h3")).filter(h => {
        const isTitle = h.classList.contains('title');
        const isEmpty = h.textContent.trim().length === 0;
        const isMarkdownHeading = isMarkdownGeneratedHeading(h);
        
        return !isTitle && !isEmpty && isMarkdownHeading;
    });

    let ticking = false;

    function updateSidebar() {
        const scrollY = window.scrollY;
        let currentActive = null;
        let currentDistance = Infinity;

        sections.forEach(section => {
            const rect = section.getBoundingClientRect();
            const distance = Math.abs(rect.top);
            
            if (distance < currentDistance && rect.top < 100) {
                currentDistance = distance;
                currentActive = section;
            }
        });

        if (currentActive) {
            updateSidebarState(currentActive);
        }
        
        ticking = false;
    }

    function updateSidebarState(activeSection) {
        const headingId = activeSection.id;
        
        // Remove active class dari semua
        document.querySelectorAll('.sidebar-menu li').forEach(item => {
            item.classList.remove('active');
        });

        // Add active ke current item
        const sidebarItem = document.querySelector(`[data-heading-id="${headingId}"]`);
        if (sidebarItem) {
            sidebarItem.classList.add('active');
            
            // Auto expand parents
            expandAllParents(sidebarItem);
            
            // Collapse unrelated sections
            collapseUnrelatedSections(sidebarItem);
        }
    }

    function expandAllParents(item) {
        let current = item.parentElement;
        
        while (current && current !== document.querySelector('.sidebar-menu')) {
            if (current.classList.contains('h2-container') || 
                current.classList.contains('h3-container')) {
                current.classList.remove('collapsed');
            }
            current = current.parentElement;
        }
    }

    function collapseUnrelatedSections(activeItem) {
        document.querySelectorAll('.h2-container').forEach(container => {
            const isActiveContainer = container.contains(activeItem) || 
                                    container.parentElement === activeItem;
            if (!isActiveContainer) {
                container.classList.add('collapsed');
            }
        });

        document.querySelectorAll('.h3-container').forEach(container => {
            const isActiveContainer = container.contains(activeItem);
            if (!isActiveContainer) {
                container.classList.add('collapsed');
            }
        });
    }

    window.addEventListener('scroll', function() {
        if (!ticking) {
            requestAnimationFrame(updateSidebar);
            ticking = true;
        }
    });

    setTimeout(updateSidebar, 100);
}

// ... (FUNGSI LAINNYA TETAP SAMA)
function initSidebarToggle() {
    const toggleSidebarBtn = document.getElementById('toggleSidebar');
    const toggleContainer = document.getElementById('sidebarToggleContainer');

    function isMobile() {
        return window.innerWidth <= 768;
    }

    function toggleSidebar() {
        const toggleBtn = document.getElementById('toggleSidebar');
        if (toggleBtn) {
            toggleBtn.classList.add('rotating');
            setTimeout(() => toggleBtn.classList.remove('rotating'), 310);
        }

        if (isMobile()) {
            document.body.classList.toggle('sidebar-mobile-open');
            updateToggleIcon();
        } else {
            document.body.classList.toggle('sidebar-collapsed');
            updateTogglePosition();
            updateToggleIcon();
        }
    }

    function updateTogglePosition() {
        const isCollapsed = document.body.classList.contains('sidebar-collapsed');
        const clearSearch = document.getElementById('clearSearch');
        if (toggleContainer) {
            if (isCollapsed) {
                toggleContainer.style.left = '10px';
                if (clearSearch) clearSearch.style.left = '10px';
            } else {
                // Dynamically calculate position based on current sidebar width
                const sidebar = document.getElementById('sidebar');
                const sidebarWidth = sidebar ? sidebar.offsetWidth : 310;
                const toggleLeft = sidebarWidth + 'px';
                toggleContainer.style.left = toggleLeft;
                if (clearSearch) clearSearch.style.left = toggleLeft;
            }
        }
    }

    function updateToggleIcon() {
        const isCollapsed = document.body.classList.contains('sidebar-collapsed');
        const isMobileOpen = document.body.classList.contains('sidebar-mobile-open');
        if (toggleSidebarBtn) {
            if (isMobile()) {
                toggleSidebarBtn.textContent = isMobileOpen ? 'âœ•' : 'â˜°';
            } else {
                toggleSidebarBtn.textContent = isCollapsed ? 'â˜°' : 'âœ•';
            }
        }
    }

    // Handle window resize to switch behavior
    function handleResize() {
        if (isMobile()) {
            // On mobile, ensure sidebar is hidden by default and toggle button is accessible
            document.body.classList.remove('sidebar-collapsed');
            if (toggleContainer) {
                toggleContainer.style.left = '5px';
            }
            // Hide search box on mobile
            const searchInput = document.getElementById('sidebarSearch');
            const clearBtn = document.getElementById('clearSearch');
            if (searchInput) searchInput.style.display = 'none';
            if (clearBtn) clearBtn.style.display = 'none';
        } else {
            // On desktop, use collapsed state
            updateTogglePosition();
            // Show search box on desktop
            const searchInput = document.getElementById('sidebarSearch');
            const clearBtn = document.getElementById('clearSearch');
            if (searchInput) searchInput.style.display = '';
            if (clearBtn) clearBtn.style.display = 'none'; // Initially hidden until search
        }
        updateToggleIcon();
    }

    if (toggleSidebarBtn) {
        toggleSidebarBtn.addEventListener('click', toggleSidebar);
    }

    // Close sidebar when clicking overlay on mobile
    document.addEventListener('click', function(e) {
        if (isMobile() && document.body.classList.contains('sidebar-mobile-open')) {
            if (e.target.matches('body::before') || e.target === document.body) {
                document.body.classList.remove('sidebar-mobile-open');
                updateToggleIcon();
            }
        }
    });

    // Initial setup
    handleResize();

    // Listen for window resize
    window.addEventListener('resize', handleResize);

    // Animation for menu items
    const menuItems = document.querySelectorAll(".sidebar-menu li");
    let d = 0;
    menuItems.forEach(item => {
        setTimeout(() => {
            item.classList.add("show");
        }, 90 * d);
        d++;
    });
}

function initThemeToggle() {
    const toggleThemeBtn = document.getElementById('toggleTheme');
    if (toggleThemeBtn) {
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            document.body.classList.add('dark-theme');
            toggleThemeBtn.textContent = 'â˜€ï¸';
        } else {
            document.body.classList.remove('dark-theme');
            toggleThemeBtn.textContent = 'ðŸŒ™';
        }

        toggleThemeBtn.addEventListener('click', function() {
            const isDark = document.body.classList.contains('dark-theme');
            
            if (isDark) {
                document.body.classList.remove('dark-theme');
                localStorage.setItem('theme', 'light');
                this.textContent = 'ðŸŒ™';
            } else {
                document.body.classList.add('dark-theme');
                localStorage.setItem('theme', 'dark');
                this.textContent = 'â˜€ï¸';
            }
        });
    }
}

function initSmoothScroll() {
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute('href'));
            if (target) {
                target.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
}

function initSearch() {
    const searchInput = document.getElementById('sidebarSearch');
    const clearBtn = document.getElementById('clearSearch');
    const sidebarMenu = document.querySelector('.sidebar-menu');

    if (!searchInput || !clearBtn || !sidebarMenu) return;

    let allItems = Array.from(sidebarMenu.querySelectorAll('li'));
    let visibleItems = [...allItems];

    function filterItems(query) {
        if (!query.trim()) {
            // Show all items
            allItems.forEach(item => {
                item.style.display = '';
                // Expand parents if needed
                expandAllParents(item);
            });
            visibleItems = [...allItems];
            return;
        }

        query = query.toLowerCase();
        visibleItems = allItems.filter(item => {
            const text = item.textContent.toLowerCase();
            const matches = text.includes(query);
            item.style.display = matches ? '' : 'none';
            return matches;
        });

        // Expand containers that have visible children
        document.querySelectorAll('.h2-container, .h3-container').forEach(container => {
            const hasVisibleChild = Array.from(container.querySelectorAll('li')).some(li => li.style.display !== 'none');
            if (hasVisibleChild) {
                container.classList.remove('collapsed');
            }
        });

        // Auto-expand parents of visible items
        visibleItems.forEach(item => {
            expandAllParents(item);
        });
    }

    function expandAllParents(item) {
        let current = item.parentElement;
        while (current && current !== sidebarMenu) {
            if (current.classList.contains('h2-container') || current.classList.contains('h3-container')) {
                current.classList.remove('collapsed');
            }
            current = current.parentElement;
        }
    }

    searchInput.addEventListener('input', function() {
        const query = this.value;
        filterItems(query);
        clearBtn.style.display = query ? 'block' : 'none';
    });

    clearBtn.addEventListener('click', function() {
        searchInput.value = '';
        filterItems('');
        this.style.display = 'none';
        searchInput.focus();
    });

    // Initial hide clear button
    clearBtn.style.display = 'none';

    // Focus on search when container is clicked (optional)
    document.getElementById('sidebarToggleContainer').addEventListener('click', function(e) {
        if (e.target === this) {
            searchInput.focus();
        }
    });
}

// Rotating Text Animation Function
// Optimized Rotating Text Animation - FIXED inline display
function initRotatingText() {
    let headerTexts = ["Data Analytics", "Data Security", "JavaScript", "Python", "Java", "SQL", "C", "R"];
    
    if (typeof texts !== 'undefined') {
        headerTexts = texts;
    }

    const rotatingTextHeader = document.getElementById('rotating-text-header');
    if (!rotatingTextHeader) return;

    let currentIndex = 0;
    let isAnimating = false;
    
    // Initialize with first text
    function initializeFirstText() {
        if (headerTexts.length === 0) return;
        
        const initialText = headerTexts[0];
        rotatingTextHeader.innerHTML = '';
        
        const characters = initialText.split('');
        characters.forEach(char => {
            const span = document.createElement('span');
            span.textContent = char;
            span.className = 'text-rotate-element';
            span.style.display = 'inline-block';
            span.style.transform = 'translateY(0)';
            span.style.opacity = '1';
            rotatingTextHeader.appendChild(span);
        });
        
        // Set initial width based on actual content
        const tempSpan = document.createElement('span');
        tempSpan.style.position = 'absolute';
        tempSpan.style.visibility = 'hidden';
        tempSpan.style.whiteSpace = 'nowrap';
        tempSpan.style.fontWeight = 'bold';
        tempSpan.style.fontSize = getComputedStyle(rotatingTextHeader).fontSize;
        tempSpan.textContent = initialText;
        document.body.appendChild(tempSpan);
        const initialWidth = tempSpan.offsetWidth + 24;
        document.body.removeChild(tempSpan);
        
        rotatingTextHeader.style.width = initialWidth + 'px';
        rotatingTextHeader.style.minWidth = initialWidth + 'px';
        
        currentIndex = 1; // Start from next item
    }
    
    function animateTransition() {
        if (isAnimating || headerTexts.length === 0) return;
        isAnimating = true;
        
        const currentText = headerTexts[(currentIndex - 1 + headerTexts.length) % headerTexts.length];
        const nextText = headerTexts[currentIndex];
        
        // Phase 1: Animate current text out
        const currentSpans = Array.from(rotatingTextHeader.querySelectorAll('.text-rotate-element'));
        
        if (currentSpans.length > 0) {
            currentSpans.forEach((span, index) => {
                span.style.transition = 'transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1), opacity 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)';
                span.style.transitionDelay = `${index * 15}ms`;
                span.style.transform = 'translateY(-120%)';
                span.style.opacity = '0';
            });
        }
        
        // Calculate new width while text is animating out
        setTimeout(() => {
            const tempSpan = document.createElement('span');
            tempSpan.style.position = 'absolute';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.whiteSpace = 'nowrap';
            tempSpan.style.fontWeight = 'bold';
            tempSpan.style.fontSize = getComputedStyle(rotatingTextHeader).fontSize;
            tempSpan.textContent = nextText;
            document.body.appendChild(tempSpan);
            const newWidth = tempSpan.offsetWidth + 24;
            document.body.removeChild(tempSpan);
            
            // Phase 2: Resize container QUICKLY (before new text appears)
            rotatingTextHeader.style.transition = 'width 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94), min-width 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            rotatingTextHeader.style.width = newWidth + 'px';
            rotatingTextHeader.style.minWidth = newWidth + 'px';
            
            // Phase 3: Clear old text and add new text after container resizes
            setTimeout(() => {
                rotatingTextHeader.innerHTML = '';
                
                const characters = nextText.split('');
                const newSpans = characters.map(char => {
                    const span = document.createElement('span');
                    span.textContent = char;
                    span.className = 'text-rotate-element';
                    span.style.display = 'inline-block';
                    span.style.transform = 'translateY(100%)';
                    span.style.opacity = '0';
                    rotatingTextHeader.appendChild(span);
                    return span;
                });
                
                // Phase 4: Animate new text in
                setTimeout(() => {
                    newSpans.forEach((span, index) => {
                        span.style.transition = 'transform 0.4s cubic-bezier(0.4, 0.0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0.0, 0.2, 1)';
                        span.style.transitionDelay = `${(characters.length - 1 - index) * 20}ms`;
                        span.style.transform = 'translateY(0)';
                        span.style.opacity = '1';
                    });
                    
                    // Reset and prepare for next animation
                    setTimeout(() => {
                        // Remove inline styles for next iteration
                        newSpans.forEach(span => {
                            span.style.transition = '';
                            span.style.transitionDelay = '';
                            span.style.transform = '';
                            span.style.opacity = '';
                        });
                        
                        currentIndex = (currentIndex + 1) % headerTexts.length;
                        isAnimating = false;
                    }, 400 + characters.length * 20);
                }, 50);
            }, 150); // Start adding new text slightly before container finishes resizing
        }, 300 + currentSpans.length * 15);
    }
    
    // Initialize
    initializeFirstText();
    
    // Start animation loop
    setTimeout(() => {
        setInterval(animateTransition, 2000);
    }, 1000);
}

</script>



